运行上述程序，可以得到输出“ABBA”，
表明程序依次调用了A::A()、B::B()、B::~B()、A::~A()。
直观上理解，在构造A时，B中的数据还没有创建，因此B重写的虚函数当然不可使用，
因此应该调用A中的版本；
反过来，析构的时候，由于B先析构，在B析构之后，B中的函数当然也不可用，因此也应该调用A中的版本。

在程序运行中，这一过程是通过动态的修改对象的虚指针实现的。

根据C++中继承类的构造顺序，首先基类A被构造。
在构造A时， 对象自身的虚指针指向A的虚表。
由于A的虚表中，f0()的位置保存着A::f0()的地址，因此A::f0()被调用。
在A的构造结束后，B的构造启动，此时虚指针被修改为指向B的虚表。析构过程与此相反。